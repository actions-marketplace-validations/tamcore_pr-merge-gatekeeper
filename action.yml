name: 'Merge Gatekeeper'
description: 'Ensures all CI checks pass before allowing a PR to be merged. Polls check runs and commit statuses, retrying while checks are in progress.'
author: 'Philipp'

branding:
  icon: 'shield'
  color: 'green'

inputs:
  token:
    description: 'GitHub token to access PR commit statuses and checks'
    required: false
    default: ${{ github.token }}
  initial-delay:
    description: 'Seconds to sleep before the first check'
    required: false
    default: '5'
  max-retries:
    description: 'Number of retries while checks are still in progress'
    required: false
    default: '5'
  polling-interval:
    description: 'Seconds to wait between retry attempts'
    required: false
    default: '60'
  ignored-name-patterns:
    description: 'Newline-separated list of regex patterns to exclude jobs from evaluation'
    required: false
    default: ''
  full-details-summary:
    description: 'Show all checks in the summary (not just failures)'
    required: false
    default: 'false'

runs:
  using: 'composite'
  steps:
    - name: Check CI Status
      uses: actions/github-script@v8
      with:
        github-token: ${{ inputs.token }}
        script: |
          // Inputs
          const initialDelay = parseInt('${{ inputs.initial-delay }}', 10);
          const maxRetries = parseInt('${{ inputs.max-retries }}', 10);
          const pollingInterval = parseInt('${{ inputs.polling-interval }}', 10);
          const ignoredPatterns = `${{ inputs.ignored-name-patterns }}`
            .split('\n')
            .map(p => p.trim())
            .filter(p => p.length > 0)
            .map(p => new RegExp(p));
          const fullDetailsSummary = '${{ inputs.full-details-summary }}' === 'true';

          // Determine the commit SHA to check
          const sha = context.payload.pull_request?.head?.sha || context.sha;
          const owner = context.repo.owner;
          const repo = context.repo.repo;
          const currentJob = process.env.GITHUB_JOB;

          core.info(`Checking commit: ${sha}`);
          core.info(`Current job: ${currentJob}`);

          /**
           * Fetch all check runs for the commit, deduplicated by app+name (keeping highest ID)
           */
          async function fetchCheckRuns() {
            const checkRuns = new Map(); // Key: "app_slug/name", Value: check run object

            // Get all check suites for the ref
            const suites = await github.paginate(
              github.rest.checks.listSuitesForRef,
              { owner, repo, ref: sha, per_page: 100 }
            );

            // For each suite, get all check runs
            for (const suite of suites) {
              const runs = await github.paginate(
                github.rest.checks.listForSuite,
                { owner, repo, check_suite_id: suite.id, per_page: 100 }
              );

              for (const run of runs) {
                // Skip runs with uninterpreted template syntax
                if (run.name.includes('${{')) {
                  core.debug(`Skipping check run with template syntax: ${run.name}`);
                  continue;
                }

                const key = `${run.app?.slug || 'unknown'}/${run.name}`;
                const existing = checkRuns.get(key);

                // Keep the run with the highest ID (most recent)
                if (!existing || run.id > existing.id) {
                  checkRuns.set(key, run);
                }
              }
            }

            return Array.from(checkRuns.values());
          }

          /**
           * Fetch all commit statuses for the commit
           */
          async function fetchCommitStatuses() {
            const statuses = await github.paginate(
              github.rest.repos.listCommitStatusesForRef,
              { owner, repo, ref: sha, per_page: 100 }
            );

            // Deduplicate by context (keep the most recent, which is first in the list)
            const seen = new Set();
            return statuses.filter(status => {
              if (seen.has(status.context)) {
                return false;
              }
              seen.add(status.context);
              return true;
            });
          }

          /**
           * Classify a check run into a category
           */
          function classifyCheckRun(run) {
            const name = run.name;
            const appSlug = run.app?.slug || 'unknown';
            const status = run.status;
            const conclusion = run.conclusion;

            // Check if this is the current job (self)
            if (name === currentJob && appSlug === 'github-actions') {
              return 'self';
            }

            // Check if this matches any ignored pattern
            for (const pattern of ignoredPatterns) {
              if (pattern.test(name)) {
                return 'ignored';
              }
            }

            // Check if still running
            if (status === 'queued' || status === 'in_progress') {
              return 'running';
            }

            // Check if successful (success, skipped, or neutral are all OK)
            if (conclusion === 'success' || conclusion === 'skipped' || conclusion === 'neutral') {
              return 'success';
            }

            // Everything else is a failure
            return 'failure';
          }

          /**
           * Classify a commit status into a category
           */
          function classifyStatus(status) {
            const context = status.context;
            const state = status.state;

            // Check if this matches any ignored pattern
            for (const pattern of ignoredPatterns) {
              if (pattern.test(context)) {
                return 'ignored';
              }
            }

            // Check if still pending
            if (state === 'pending') {
              return 'running';
            }

            // Check if successful
            if (state === 'success') {
              return 'success';
            }

            // Everything else is a failure
            return 'failure';
          }

          /**
           * Perform a single check and return the results
           */
          async function performCheck() {
            const checkRuns = await fetchCheckRuns();
            const statuses = await fetchCommitStatuses();

            const results = [];
            let hasFailure = false;
            let hasRunning = false;
            let foundSelf = false;

            // Process check runs
            for (const run of checkRuns) {
              const category = classifyCheckRun(run);
              results.push({
                name: run.name,
                type: 'check_run',
                category,
                status: run.status,
                conclusion: run.conclusion,
                url: run.html_url
              });

              if (category === 'self') foundSelf = true;
              if (category === 'failure') hasFailure = true;
              if (category === 'running') hasRunning = true;
            }

            // Process commit statuses
            for (const status of statuses) {
              const category = classifyStatus(status);
              results.push({
                name: status.context,
                type: 'status',
                category,
                status: status.state,
                conclusion: status.state,
                url: status.target_url
              });

              if (category === 'failure') hasFailure = true;
              if (category === 'running') hasRunning = true;
            }

            if (!foundSelf) {
              core.warning('Could not find current job in check runs. This may be due to API lag.');
            }

            return { results, hasFailure, hasRunning, foundSelf };
          }

          /**
           * Sleep for a specified number of seconds
           */
          function sleep(seconds) {
            return new Promise(resolve => setTimeout(resolve, seconds * 1000));
          }

          /**
           * Main retry loop
           */
          async function run() {
            const runAttempt = parseInt(process.env.GITHUB_RUN_ATTEMPT || '1', 10);

            // If this is a re-run, do an immediate check first
            if (runAttempt > 1) {
              core.info('Re-run detected, performing immediate check...');
              const { results, hasFailure, hasRunning } = await performCheck();

              if (!hasRunning) {
                return { results, hasFailure };
              }
              core.info('Checks still running, will continue with retry loop...');
            }

            // Initial delay before first check
            core.info(`Waiting ${initialDelay} seconds before first check...`);
            await sleep(initialDelay);

            let lastResults = null;
            let lastHasFailure = false;

            for (let attempt = 0; attempt <= maxRetries; attempt++) {
              if (attempt > 0) {
                core.info(`Waiting ${pollingInterval} seconds before retry ${attempt}/${maxRetries}...`);
                await sleep(pollingInterval);
              }

              core.info(`Performing check (attempt ${attempt + 1}/${maxRetries + 1})...`);
              const { results, hasFailure, hasRunning } = await performCheck();

              lastResults = results;
              lastHasFailure = hasFailure;

              if (!hasRunning) {
                core.info('All checks have completed.');
                return { results, hasFailure };
              }

              const runningCount = results.filter(r => r.category === 'running').length;
              core.info(`${runningCount} check(s) still running...`);
            }

            // Max retries exhausted
            core.warning('Max retries exhausted with checks still running.');
            return { results: lastResults, hasFailure: true, timedOut: true };
          }

          // TODO: Generate summary

          core.info('Merge Gatekeeper initialized');
          core.info(`Initial delay: ${initialDelay}s`);
          core.info(`Max retries: ${maxRetries}`);
          core.info(`Polling interval: ${pollingInterval}s`);
          core.info(`Ignored patterns: ${ignoredPatterns.length}`);
          core.info(`Full details summary: ${fullDetailsSummary}`);
